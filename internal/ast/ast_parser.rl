package ast

// Code generated by ragel; DO NOT EDIT.

%%{
	machine lol;
	alphtype rune;
	write data;
}%%

func c(r int) rune {
	return rune(r)
}

func (parser *Parser) parse(data []rune) (*Program, error) {
	parser.data = data
	program := &Program{}

	eof := len(data);
	cs, p, pe := 0, 0, eof;
	%%{

	action addVISIBLE {
	    program.addVISIBLE(parser.getMark())
	}
	action addYARN {
	    program.addYARN(parser.getYARN(fpc))
	}
	action setMark {
	    parser.setMark(fpc)
	}
	action trace {
	    parser.trace(rune(fc), fpc)
	}

	nl = ( '\r'?'\n'|'\r''\n'? ) %from{ parser.startLine(fpc) };
	ws = [ \t];
	sep = ws+;

	btw = ws* 'BTW' (ws [^\r\n]+)?;
	eol = btw? nl;
	obtw = ws* 'OBTW' (ws [^\r\n]+)? nl ([^\r\n]* nl)* ([^\r\n]+ ws)? 'TLDR' ws* nl;

	head = ws* ('HAI' sep '1.2') $err{ parser.setError(fpc, "invalid version declaration") };
	tail = ws* ('KTHXBYE') $err{ parser.setError(fpc, "expected: \"KTHXBYE\"") };

	yarn = (
	    start: (
		'"' -> raw
	    ),
	    raw: (
		':' -> one |
		'"' -> final |
		(any-[:"\r\n]) -> raw
	    ),
	    one: (
		any -> raw
	    )
	) >setMark %addYARN
	  <err{ parser.setError(fpc, "unexpected end of YARN") };
	expr = yarn >err{ parser.setError(fpc, "expected: YARN") };

	visible = (
	    'VISIBLE' >setMark @err{ parser.setError(fpc, "expected: \"VISIBLE\"") }
	    sep @addVISIBLE
	    expr (sep expr)*
	);
	statement = ws* visible;

	main := (( obtw|ws* eol )*
		head eol
		( obtw|ws* statement? eol )*
		tail ( eol
		  ( obtw|ws* eol )*
		) ws* ) $trace;

	write init;
	write exec;
	}%%

	if cs < lol_first_final {
		return nil, parser.getError(cs)
	}

	return program, nil
}
